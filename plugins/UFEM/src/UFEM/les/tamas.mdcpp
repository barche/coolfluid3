
// > Hey,
// >
// > Here is the file, it is Morpheus macro, but I think it is still readable.
// >
// > How it works:
// >
// >     vkiles_dynamicsmagorinsky_3d_compute_sgs_dynvisc is your main hook, this computes nu_sgs.
// >     Within this function is the call to les_calc_Cs_for_dynsmago, which computes Cs^2, that is where all the dynamic Smagorinsky magic happens (If you replace that by the square of the appropriate constant, you are back to static Smagorinsky)
// >     In les_calc_Cs_for_dynsmago the morpheus specific part is the beginning: it basically calculates derivatives over an element and also the area averaged derivatives over all the elements (including the center elem) connected by node to this; the rest follows the nomenclature in my thesis 
// >
// > The way I built this:
// >
// >     Change the N.S. code to nu-> mu_effective=mu_lam+mu_sgs
// >     Plug in static Smagorinsky (without wall damping) and validate it on some sinusoidal initial flow field
// >     Plug in dynamic Cs calculator and validate it
// >     Plug in wall_damping: that is nasty business because you need wall shear stress and wall distance to the nearest wall boundary on a partitioned mesh. I guess you can simplify this for ABL:
// >         use elevation data for wall distance and ignore buildings
// >         interpolate wall shear stress to some reduced resolution equidistant rectangular grid and broadcast it on all partitions (so from x-z coordinates you can find i-j)

// file real name: les_dynamicsmagorinsky.c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "les/les_base.h"
#include "les/les_dynamicsmagorinsky.h"


/* model's data set */
static VKILES_DYNAMICSMAGORINSKY_DATA md;


/* wall damping selections */
#define WALL_DAMPING_OFF          0
#define WALL_DAMPING_VANDRIEST    1
#define WALL_DAMPING_PIOMELLI     2
#define WALL_DAMPING_MIXINGLENGTH 3


/* setup */
void vkiles_dynamicsmagorinsky_initialize( int dim ){
  PUTPARAM("LES_FILTER_SIZE","%u","1",&(md.FilterSize));
  PUTPARAM("LES_WALL_KAPPA","%lf","0.41",&(md.WallKappa));
  PUTPARAM("LES_WALL_C","%lf","5.",&(md.WallC));
  char walldamping[32]; walldamping[0]='\0';
  PUTPARAM("LES_WALL_DAMPING","%s","VANDRIEST",walldamping);
  if (strcmp(walldamping,"OFF")==0)          md.WallDamping=WALL_DAMPING_OFF;
  if (strcmp(walldamping,"VANDRIEST")==0)    md.WallDamping=WALL_DAMPING_VANDRIEST;
  if (strcmp(walldamping,"PIOMELLI")==0)     md.WallDamping=WALL_DAMPING_PIOMELLI;
  if (strcmp(walldamping,"MIXINGLENGTH")==0) md.WallDamping=WALL_DAMPING_MIXINGLENGTH;
  md.NbDataPoints=0;
  md.MaxDataPoints=0;
  md.VelocitySet=(double*)malloc(1);
  md.VelGrad=(double*)malloc(1);
}


/* destroy */
void vkiles_dynamicsmagorinsky_finalize(){
  free(md.VelocitySet);
  free(md.VelGrad);
}


/* get_config_param */
void vkiles_dynamicsmagorinsky_get_config_param(char* param_name,char* param_value){
  GETPARAM("LES_FILTER_SIZE","%u",md.FilterSize);
  GETPARAM("LES_WALL_KAPPA","%lf",md.WallKappa);
  GETPARAM("LES_WALL_C","%lf",md.WallC);
  if (md.WallDamping==WALL_DAMPING_OFF)          GETPARAM("LES_WALL_DAMPING","%s","OFF");
  if (md.WallDamping==WALL_DAMPING_VANDRIEST)    GETPARAM("LES_WALL_DAMPING","%s","VANDRIEST");
  if (md.WallDamping==WALL_DAMPING_PIOMELLI)     GETPARAM("LES_WALL_DAMPING","%s","PIOMELLI");
  if (md.WallDamping==WALL_DAMPING_MIXINGLENGTH) GETPARAM("LES_WALL_DAMPING","%s","MIXINGLENGTH");
}


/* 2d version */
void vkiles_dynamicsmagorinsky_2d_compute_sgs_dynvisc( double* eddy_visc ){

  double S,Ls,V,Cs,rho,yw,dudyw,mulam,yplus;
  double *du,*dv;

  les_put_filter_properties(md.FilterSize,1,&md.NbDataPoints);
  if (md.NbDataPoints>md.MaxDataPoints) {
    md.VelocitySet=(double*)realloc(md.VelocitySet,2*md.NbDataPoints*sizeof(double));
    md.VelGrad=(double*)realloc(md.VelGrad,2*2*1*sizeof(double));
  }
  les_put_velocity_set(md.VelocitySet);
  les_grad_variable(2,md.VelocitySet,md.VelGrad);
  du=&(md.VelGrad[0]);
  dv=&(md.VelGrad[2]);
  les_put_volume(&V);
  les_put_density(&rho);
  les_put_wall_distance(&yw);
  les_put_wall_grad_vel_magnitude(&dudyw);
  les_put_laminar_dynvisc(&mulam);

  ERRMSG(-1,"%s","Cs2 calculation implemented for 3d only.\n");
  les_calc_Cs_for_dynsmago(&Cs);

  S= 2.*(du[0]*du[0]+dv[1]*dv[1])
    +(du[1]+dv[0])*(du[1]+dv[0]);
  S= sqrt(S);
  yplus= yw*sqrt(rho/mulam*dudyw);

  Ls=pow(V,1./2.)*Cs;
  if (md.WallDamping==WALL_DAMPING_OFF){
    *eddy_visc= rho*Ls*Ls*S;
  }
  if (md.WallDamping==WALL_DAMPING_VANDRIEST){
    yplus= yw*sqrt(rho/mulam*dudyw);
    if (yplus<300) Ls*= (1.-exp(-yplus/25.));
    *eddy_visc= rho*Ls*Ls*S;
  }
  if (md.WallDamping==WALL_DAMPING_PIOMELLI){
    yplus= yw*sqrt(rho/mulam*dudyw);
    *eddy_visc= rho*Ls*Ls*S;
    if (yplus<100) *eddy_visc*= (1.-exp(-yplus*yplus*yplus/15625.)); // 15625=25*25*25
  }
  if (md.WallDamping==WALL_DAMPING_MIXINGLENGTH){
    *eddy_visc= rho*Ls*Ls*S;
    if (*eddy_visc > md.WallKappa*yw) *eddy_visc=md.WallKappa*yw;
  }

}


/* 3d version*/
void vkiles_dynamicsmagorinsky_3d_compute_sgs_dynvisc( double* eddy_visc ){

  double S,Ls,V,Cs,rho,yw,dudyw,mulam,yplus;
  double *du,*dv,*dw;

  les_put_filter_properties(md.FilterSize,1,&md.NbDataPoints);
  if (md.NbDataPoints>md.MaxDataPoints) {
    md.VelocitySet=(double*)realloc(md.VelocitySet,3*md.NbDataPoints*sizeof(double));
    md.VelGrad=(double*)realloc(md.VelGrad,3*3*1*sizeof(double));
  }
  les_put_velocity_set(md.VelocitySet);
  les_grad_variable(3,md.VelocitySet,md.VelGrad);
  du=&(md.VelGrad[0]);
  dv=&(md.VelGrad[3]);
  dw=&(md.VelGrad[6]);
  les_put_volume(&V);
  les_put_density(&rho);
  les_put_wall_distance(&yw);
  les_put_wall_grad_vel_magnitude(&dudyw);
  les_put_laminar_dynvisc(&mulam);
  les_calc_Cs_for_dynsmago(&Cs);

  S= 2.*(du[0]*du[0]+dv[1]*dv[1]+dw[2]*dw[2])
    +(du[1]+dv[0])*(du[1]+dv[0])
    +(du[2]+dw[0])*(du[2]+dw[0])
    +(dv[2]+dw[1])*(dv[2]+dw[1]);
  S= sqrt(S);

  Ls=pow(V,1./3.)*Cs;
  if (md.WallDamping==WALL_DAMPING_OFF){
    *eddy_visc= rho*Ls*Ls*S;
  }
  if (md.WallDamping==WALL_DAMPING_VANDRIEST){
    yplus= yw*sqrt(rho/mulam*dudyw);
    if (yplus<300) Ls*= (1.-exp(-yplus/25.));
    *eddy_visc= rho*Ls*Ls*S;
  }
  if (md.WallDamping==WALL_DAMPING_PIOMELLI){
    yplus= yw*sqrt(rho/mulam*dudyw);
    *eddy_visc= rho*Ls*Ls*S;
    if (yplus<100) *eddy_visc*= (1.-exp(-yplus*yplus*yplus/15625.)); // 15625=25*25*25
  }
  if (md.WallDamping==WALL_DAMPING_MIXINGLENGTH){
    *eddy_visc= rho*Ls*Ls*S;
    if (*eddy_visc > md.WallKappa*yw) *eddy_visc=md.WallKappa*yw;
  }

}


/* Those are not used in framework of VkiLES so far ... */
void vkiles_dynamicsmagorinsky_2d_compute_thermal_cond( double* thermal_cond ){ERRMSG(-1,"%s\n","Function not implemented.");}
void vkiles_dynamicsmagorinsky_3d_compute_thermal_cond( double* thermal_cond ){ERRMSG(-1,"%s\n","Function not implemented.");}
void vkiles_dynamicsmagorinsky_2d_compute_sgs_shearstress( double* sgs_stress ){ERRMSG(-1,"%s\n","Function not implemented.");}
void vkiles_dynamicsmagorinsky_3d_compute_sgs_shearstress( double* sgs_stress ){ERRMSG(-1,"%s\n","Function not implemented.");}
void vkiles_dynamicsmagorinsky_2d_compute_sgs_heatflux( double* sgs_heatflux ){ERRMSG(-1,"%s\n","Function not implemented.");}
void vkiles_dynamicsmagorinsky_3d_compute_sgs_heatflux( double* sgs_heatflux ){ERRMSG(-1,"%s\n","Function not implemented.");}


/* Calculates everything for dynamic smagorinsky 
   CAREFUL: this returns the square of Cs as argument
*/
void _MBEGIN_(les_calc_Cs_for_dynsmago, double* Cs)

  int vanum,*vaptr,i,j,centerelm=-1;
  int stencilelms[1000],nstencilelms=0;
  double invvol;
  double d[3][3],u[3000],S[9000],V[1000],data[100],M[3][3],L[3][3];

  // calculating stencilelms, elements that are connected to the l2m.currElm by node
  for (i=0; i<(const int)(palldata->dim->numDim+1); i++){
    vanum=numVA(&palldata->mesh->nodElms,palldata->mesh->elmNodes[l2m.currElm][i]);
    vaptr=ptrVA(&palldata->mesh->nodElms,palldata->mesh->elmNodes[l2m.currElm][i]);
    for (j=0; j<(const int)(vanum); j++) 
      stencilelms[nstencilelms++]=vaptr[j];
  }
  
  // remove element duplicates
  qsort(stencilelms,nstencilelms,sizeof(int),compare_ints);
  j=1;
  for (i=0; i<nstencilelms-1; i++)
    if (stencilelms[i]!=stencilelms[i+1])
      stencilelms[j++]=stencilelms[i+1];
  nstencilelms=j;
  for (i=0; i<nstencilelms-1; i++) 
    assert(stencilelms[i]!=stencilelms[i+1]);
  for (i=0; i<nstencilelms; i++) 
    if (stencilelms[i]==l2m.currElm)
      centerelm=i;

  // calculating u,S,V on elements
  memset(u,0,3*nstencilelms*sizeof(double));
  memset(S,0,9*nstencilelms*sizeof(double));
  for (i=0; i<nstencilelms; i++) {
    V[i]=palldata->mesh->elmVolumes[stencilelms[i]];
    invvol=1./(((double)palldata->dim->numDim)*V[i]);
    d[0][0]=0.;d[1][0]=0.;d[2][0]=0.;
    d[0][1]=0.;d[1][1]=0.;d[2][1]=0.;
    d[0][2]=0.;d[1][2]=0.;d[2][2]=0.;
    for (j=0; j<(const int)(palldata->dim->numDim+1); j++){
      int inod=palldata->mesh->elmNodes[stencilelms[i]][j];
      d[0][0]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[0]]*palldata->mesh->elmNorms[stencilelms[i]][j][0];
      d[0][1]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[0]]*palldata->mesh->elmNorms[stencilelms[i]][j][1];
      d[0][2]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[0]]*palldata->mesh->elmNorms[stencilelms[i]][j][2];
      d[1][0]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[1]]*palldata->mesh->elmNorms[stencilelms[i]][j][0];
      d[1][1]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[1]]*palldata->mesh->elmNorms[stencilelms[i]][j][1];
      d[1][2]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[1]]*palldata->mesh->elmNorms[stencilelms[i]][j][2];
      d[2][0]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[2]]*palldata->mesh->elmNorms[stencilelms[i]][j][0];
      d[2][1]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[2]]*palldata->mesh->elmNorms[stencilelms[i]][j][1];
      d[2][2]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[2]]*palldata->mesh->elmNorms[stencilelms[i]][j][2];
      u[i*3+0]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[0]];
      u[i*3+1]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[1]];
      u[i*3+2]+=palldata->sol->UNKp05[palldata->dim->numUnk*inod+l2m.velidx[2]];
    }
    d[0][0]*=invvol;d[1][0]*=invvol;d[2][0]*=invvol;
    d[0][1]*=invvol;d[1][1]*=invvol;d[2][1]*=invvol;
    d[0][2]*=invvol;d[1][2]*=invvol;d[2][2]*=invvol;
    u[i*3+0]*=1./((double)palldata->dim->numDim+1);
    u[i*3+1]*=1./((double)palldata->dim->numDim+1);
    u[i*3+2]*=1./((double)palldata->dim->numDim+1);
    S[9*i+0]=.5*(d[0][0]+d[0][0]);
    S[9*i+1]=.5*(d[0][1]+d[1][0]);
    S[9*i+2]=.5*(d[0][2]+d[2][0]);
    S[9*i+3]=.5*(d[1][0]+d[0][1]);
    S[9*i+4]=.5*(d[1][1]+d[1][1]);
    S[9*i+5]=.5*(d[1][2]+d[2][1]);
    S[9*i+6]=.5*(d[2][0]+d[0][2]);
    S[9*i+7]=.5*(d[2][1]+d[1][2]);
    S[9*i+8]=.5*(d[2][2]+d[2][2]);
  }
  
  // preparing data
  //  0        -  V           grid filter volume
  //  1        -  V_t         test filter volume
  //  2 ..  4  -  Ui_t        grid + test filtered velocity components
  //  5 .. 13  -  Sij_t       grid + test filtered strain tensor
  // 14        -  |S|_t       grid + test filtered strain tensor magnitude
  // 15 .. 23  -  (UiUj)_t    grid + test filtered velocity products
  // 24 .. 32  -  (|S|Sij)_t  grid + test filtered strain tensor product
  memset(data,0,100*sizeof(double));
  
  // caclculating segregated rt filtering products
  data[0]=V[centerelm];
  for (i=0; i<nstencilelms; i++) {
    double SSij;
    data[ 1]+=V[i];
    data[ 2]+=u[3*i+0]*V[i];
    data[ 3]+=u[3*i+1]*V[i];
    data[ 4]+=u[3*i+2]*V[i];
    data[ 5]+=S[9*i+0]*V[i];
    data[ 6]+=S[9*i+1]*V[i];
    data[ 7]+=S[9*i+2]*V[i];
    data[ 8]+=S[9*i+3]*V[i];
    data[ 9]+=S[9*i+4]*V[i];
    data[10]+=S[9*i+5]*V[i];
    data[11]+=S[9*i+6]*V[i];
    data[12]+=S[9*i+7]*V[i];
    data[13]+=S[9*i+8]*V[i];
    //data[14] see down
    data[15]+=u[3*i+0]*u[3*i+0]*V[i];
    data[16]+=u[3*i+0]*u[3*i+1]*V[i];
    data[17]+=u[3*i+0]*u[3*i+2]*V[i];
    data[18]+=u[3*i+1]*u[3*i+0]*V[i];
    data[19]+=u[3*i+1]*u[3*i+1]*V[i];
    data[20]+=u[3*i+1]*u[3*i+2]*V[i];
    data[21]+=u[3*i+2]*u[3*i+0]*V[i];
    data[22]+=u[3*i+2]*u[3*i+1]*V[i];
    data[23]+=u[3*i+2]*u[3*i+2]*V[i];
    SSij=sqrt(2.*( S[9*i+0]*S[9*i+0]+S[9*i+1]*S[9*i+1]+S[9*i+2]*S[9*i+2]
                  +S[9*i+3]*S[9*i+3]+S[9*i+4]*S[9*i+4]+S[9*i+5]*S[9*i+5]
                  +S[9*i+6]*S[9*i+6]+S[9*i+7]*S[9*i+7]+S[9*i+8]*S[9*i+8]));
    data[24]+=SSij*S[9*i+0]*V[i];
    data[25]+=SSij*S[9*i+1]*V[i];
    data[26]+=SSij*S[9*i+2]*V[i];
    data[27]+=SSij*S[9*i+3]*V[i];
    data[28]+=SSij*S[9*i+4]*V[i];
    data[29]+=SSij*S[9*i+5]*V[i];
    data[30]+=SSij*S[9*i+6]*V[i];
    data[31]+=SSij*S[9*i+7]*V[i];
    data[32]+=SSij*S[9*i+8]*V[i];
  }
  invvol=1./data[1];
  data[ 2]*=invvol;
  data[ 3]*=invvol;
  data[ 4]*=invvol;
  data[ 5]*=invvol;
  data[ 6]*=invvol;
  data[ 7]*=invvol;
  data[ 8]*=invvol;
  data[ 9]*=invvol;
  data[10]*=invvol;
  data[11]*=invvol;
  data[12]*=invvol;
  data[13]*=invvol;
  data[14]=sqrt(2.*( data[ 5]*data[ 5]+data[ 6]*data[ 6]+data[ 7]*data[ 7]
                    +data[ 8]*data[ 8]+data[ 9]*data[ 9]+data[10]*data[10]
                    +data[11]*data[11]+data[12]*data[12]+data[13]*data[13]));
  data[15]*=invvol;
  data[16]*=invvol;
  data[17]*=invvol;
  data[18]*=invvol;
  data[19]*=invvol;
  data[20]*=invvol;
  data[21]*=invvol;
  data[22]*=invvol;
  data[23]*=invvol;
  data[24]*=invvol;
  data[25]*=invvol;
  data[26]*=invvol;
  data[27]*=invvol;
  data[28]*=invvol;
  data[29]*=invvol;
  data[30]*=invvol;
  data[31]*=invvol;
  data[32]*=invvol;

  data[0]=pow(data[0],1./3.);
  data[1]=pow(data[1],1./3.);

  M[0][0]= data[0]*data[0]*data[24] - data[1]*data[1]*data[14]*data[ 5];
  M[0][1]= data[0]*data[0]*data[25] - data[1]*data[1]*data[14]*data[ 6];
  M[0][2]= data[0]*data[0]*data[26] - data[1]*data[1]*data[14]*data[ 7];
  M[1][0]= data[0]*data[0]*data[27] - data[1]*data[1]*data[14]*data[ 8];
  M[1][1]= data[0]*data[0]*data[28] - data[1]*data[1]*data[14]*data[ 9];
  M[1][2]= data[0]*data[0]*data[29] - data[1]*data[1]*data[14]*data[10];
  M[2][0]= data[0]*data[0]*data[30] - data[1]*data[1]*data[14]*data[11];
  M[2][1]= data[0]*data[0]*data[31] - data[1]*data[1]*data[14]*data[12];
  M[2][2]= data[0]*data[0]*data[32] - data[1]*data[1]*data[14]*data[13];

  L[0][0]= data[15] - data[2]*data[2];
  L[0][1]= data[16] - data[2]*data[3];
  L[0][2]= data[17] - data[2]*data[4];
  L[1][0]= data[18] - data[3]*data[2];
  L[1][1]= data[19] - data[3]*data[3];
  L[1][2]= data[20] - data[3]*data[4];
  L[2][0]= data[21] - data[4]*data[2];
  L[2][1]= data[22] - data[4]*data[3];
  L[2][2]= data[23] - data[4]*data[4];

  *Cs= (L[0][0]*M[0][0]+L[0][1]*M[0][1]+L[0][2]*M[0][2]+
        L[1][0]*M[1][0]+L[1][1]*M[1][1]+L[1][2]*M[1][2]+
        L[2][0]*M[2][0]+L[2][1]*M[2][1]+L[2][2]*M[2][2]);
  
  *Cs/=(M[0][0]*M[0][0]+M[0][1]*M[0][1]+M[0][2]*M[0][2]+
        M[1][0]*M[1][0]+M[1][1]*M[1][1]+M[1][2]*M[1][2]+
        M[2][0]*M[2][0]+M[2][1]*M[2][1]+M[2][2]*M[2][2]);
  *Cs*= 0.5;

  *Cs=fmax(*Cs,0.);
  *Cs=fmin(sqrt(*Cs),0.23);

/*
if (l2m.currElm==13908){

_MMESSAGE_(0,0,"nstencilelms= %d  centerelm= %d\n",nstencilelms,centerelm);
_MMESSAGE_(0,0,"stencilelms= ");
for (i=0; i<nstencilelms; i++) _MAPPEND_(0,"%d ",stencilelms[i]); _MAPPEND_(0,"\n");

_MMESSAGE_(0,0,"V= % e  Vt= % e\n",data[0],data[1]);

_MMESSAGE_(0,0,"L= % e % e % e\n",L[0][0],L[0][1],L[0][2]);
_MMESSAGE_(0,0,"   % e % e % e\n",L[1][0],L[1][1],L[1][2]);
_MMESSAGE_(0,0,"   % e % e % e\n",L[2][0],L[2][1],L[2][2]);
_MMESSAGE_(0,0,"M= % e % e % e\n",M[0][0],M[0][1],M[0][2]);
_MMESSAGE_(0,0,"   % e % e % e\n",M[1][0],M[1][1],M[1][2]);
_MMESSAGE_(0,0,"   % e % e % e\n",M[2][0],M[2][1],M[2][2]);

_MMESSAGE_(0,0,"Cs= % e\n",*Cs);
}
*/
  /*WVGDEBUG*/    debugcsdyn[l2m.currElm]=*Cs;


_MEND_()